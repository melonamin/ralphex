// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"

	"github.com/umputun/ralphex/pkg/progress"
)

// LoggerMock is a mock implementation of processor.Logger.
//
//	func TestSomethingThatUsesLogger(t *testing.T) {
//
//		// make and configure a mocked processor.Logger
//		mockedLogger := &LoggerMock{
//			PathFunc: func() string {
//				panic("mock out the Path method")
//			},
//			PrintFunc: func(format string, args ...any)  {
//				panic("mock out the Print method")
//			},
//			PrintAlignedFunc: func(text string)  {
//				panic("mock out the PrintAligned method")
//			},
//			PrintRawFunc: func(format string, args ...any)  {
//				panic("mock out the PrintRaw method")
//			},
//			PrintSectionFunc: func(name string)  {
//				panic("mock out the PrintSection method")
//			},
//			SetPhaseFunc: func(phase progress.Phase)  {
//				panic("mock out the SetPhase method")
//			},
//		}
//
//		// use mockedLogger in code that requires processor.Logger
//		// and then make assertions.
//
//	}
type LoggerMock struct {
	// PathFunc mocks the Path method.
	PathFunc func() string

	// PrintFunc mocks the Print method.
	PrintFunc func(format string, args ...any)

	// PrintAlignedFunc mocks the PrintAligned method.
	PrintAlignedFunc func(text string)

	// PrintRawFunc mocks the PrintRaw method.
	PrintRawFunc func(format string, args ...any)

	// PrintSectionFunc mocks the PrintSection method.
	PrintSectionFunc func(name string)

	// SetPhaseFunc mocks the SetPhase method.
	SetPhaseFunc func(phase progress.Phase)

	// calls tracks calls to the methods.
	calls struct {
		// Path holds details about calls to the Path method.
		Path []struct {
		}
		// Print holds details about calls to the Print method.
		Print []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// PrintAligned holds details about calls to the PrintAligned method.
		PrintAligned []struct {
			// Text is the text argument value.
			Text string
		}
		// PrintRaw holds details about calls to the PrintRaw method.
		PrintRaw []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// PrintSection holds details about calls to the PrintSection method.
		PrintSection []struct {
			// Name is the name argument value.
			Name string
		}
		// SetPhase holds details about calls to the SetPhase method.
		SetPhase []struct {
			// Phase is the phase argument value.
			Phase progress.Phase
		}
	}
	lockPath         sync.RWMutex
	lockPrint        sync.RWMutex
	lockPrintAligned sync.RWMutex
	lockPrintRaw     sync.RWMutex
	lockPrintSection sync.RWMutex
	lockSetPhase     sync.RWMutex
}

// Path calls PathFunc.
func (mock *LoggerMock) Path() string {
	if mock.PathFunc == nil {
		panic("LoggerMock.PathFunc: method is nil but Logger.Path was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPath.Lock()
	mock.calls.Path = append(mock.calls.Path, callInfo)
	mock.lockPath.Unlock()
	return mock.PathFunc()
}

// PathCalls gets all the calls that were made to Path.
// Check the length with:
//
//	len(mockedLogger.PathCalls())
func (mock *LoggerMock) PathCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPath.RLock()
	calls = mock.calls.Path
	mock.lockPath.RUnlock()
	return calls
}

// Print calls PrintFunc.
func (mock *LoggerMock) Print(format string, args ...any) {
	if mock.PrintFunc == nil {
		panic("LoggerMock.PrintFunc: method is nil but Logger.Print was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPrint.Lock()
	mock.calls.Print = append(mock.calls.Print, callInfo)
	mock.lockPrint.Unlock()
	mock.PrintFunc(format, args...)
}

// PrintCalls gets all the calls that were made to Print.
// Check the length with:
//
//	len(mockedLogger.PrintCalls())
func (mock *LoggerMock) PrintCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockPrint.RLock()
	calls = mock.calls.Print
	mock.lockPrint.RUnlock()
	return calls
}

// PrintAligned calls PrintAlignedFunc.
func (mock *LoggerMock) PrintAligned(text string) {
	if mock.PrintAlignedFunc == nil {
		panic("LoggerMock.PrintAlignedFunc: method is nil but Logger.PrintAligned was just called")
	}
	callInfo := struct {
		Text string
	}{
		Text: text,
	}
	mock.lockPrintAligned.Lock()
	mock.calls.PrintAligned = append(mock.calls.PrintAligned, callInfo)
	mock.lockPrintAligned.Unlock()
	mock.PrintAlignedFunc(text)
}

// PrintAlignedCalls gets all the calls that were made to PrintAligned.
// Check the length with:
//
//	len(mockedLogger.PrintAlignedCalls())
func (mock *LoggerMock) PrintAlignedCalls() []struct {
	Text string
} {
	var calls []struct {
		Text string
	}
	mock.lockPrintAligned.RLock()
	calls = mock.calls.PrintAligned
	mock.lockPrintAligned.RUnlock()
	return calls
}

// PrintRaw calls PrintRawFunc.
func (mock *LoggerMock) PrintRaw(format string, args ...any) {
	if mock.PrintRawFunc == nil {
		panic("LoggerMock.PrintRawFunc: method is nil but Logger.PrintRaw was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPrintRaw.Lock()
	mock.calls.PrintRaw = append(mock.calls.PrintRaw, callInfo)
	mock.lockPrintRaw.Unlock()
	mock.PrintRawFunc(format, args...)
}

// PrintRawCalls gets all the calls that were made to PrintRaw.
// Check the length with:
//
//	len(mockedLogger.PrintRawCalls())
func (mock *LoggerMock) PrintRawCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockPrintRaw.RLock()
	calls = mock.calls.PrintRaw
	mock.lockPrintRaw.RUnlock()
	return calls
}

// PrintSection calls PrintSectionFunc.
func (mock *LoggerMock) PrintSection(name string) {
	if mock.PrintSectionFunc == nil {
		panic("LoggerMock.PrintSectionFunc: method is nil but Logger.PrintSection was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockPrintSection.Lock()
	mock.calls.PrintSection = append(mock.calls.PrintSection, callInfo)
	mock.lockPrintSection.Unlock()
	mock.PrintSectionFunc(name)
}

// PrintSectionCalls gets all the calls that were made to PrintSection.
// Check the length with:
//
//	len(mockedLogger.PrintSectionCalls())
func (mock *LoggerMock) PrintSectionCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockPrintSection.RLock()
	calls = mock.calls.PrintSection
	mock.lockPrintSection.RUnlock()
	return calls
}

// SetPhase calls SetPhaseFunc.
func (mock *LoggerMock) SetPhase(phase progress.Phase) {
	if mock.SetPhaseFunc == nil {
		panic("LoggerMock.SetPhaseFunc: method is nil but Logger.SetPhase was just called")
	}
	callInfo := struct {
		Phase progress.Phase
	}{
		Phase: phase,
	}
	mock.lockSetPhase.Lock()
	mock.calls.SetPhase = append(mock.calls.SetPhase, callInfo)
	mock.lockSetPhase.Unlock()
	mock.SetPhaseFunc(phase)
}

// SetPhaseCalls gets all the calls that were made to SetPhase.
// Check the length with:
//
//	len(mockedLogger.SetPhaseCalls())
func (mock *LoggerMock) SetPhaseCalls() []struct {
	Phase progress.Phase
} {
	var calls []struct {
		Phase progress.Phase
	}
	mock.lockSetPhase.RLock()
	calls = mock.calls.SetPhase
	mock.lockSetPhase.RUnlock()
	return calls
}
